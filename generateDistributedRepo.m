function aggRepo = generateDistributedRepo(repos, totalAggNum, distribResults, distribBins)
%Generates a repository containing aggregates scaled based on a distribution generate from a grain size analysis of binary images
%Inputs:
%   repos: the struct of form (aggName -> Points, Faces) generated by generateRepo
%   totalAggNum: the total number of aggregates needed to be generate. A
%   larger number is more representative of the distribution
%   distribResults: a 1xn cell containing the results of the grain size
%   analysis
%   distribBins: a mx1 cell containg the lengths (bins) of the grains 
%Outputs:
%   aggRepo: a struct containing totalAggNum of aggregates with points
%   scaled based onbin sizes and the distribution
   
    %Creating a cell with the total number of aggregates in each bin based
    %on the distribution
    distribResults = round(distribResults/100, 3);
    binSizes = distribResults * totalAggNum;
    binSizes = round(binSizes);
    
    aggRepo = struct;
    aggNames = fieldnames(repos);
    oriNames = fieldnames(repos.(aggNames{1}).Orientation);
    
    %Looping through the bin sizes
    for bin = 2:length(binSizes)
        if binSizes(bin) == 0
            continue
        end
        
        binAggNum = 0;
        aggSizes = linspace(round(distribBins(bin-1)), round(distribBins(bin)), 100);
        
        %Creating new scaled aggregates
        while binAggNum < binSizes(bin)
            aggRandNum = randi(length(aggNames), 1);
            curAggName = aggNames{aggRandNum};
            oriRandNum = randi(length(oriNames), 1);
            oriName = oriNames{oriRandNum};
                
            %Create index for orientation
            oriX = str2num(oriName(8));
            oriY = str2num(oriName(16));
            oriZ = str2num(oriName(24));
            oriMat = [oriX oriY oriZ];
            
            newName = strcat(curAggName, "_", oriName(8), oriName(16), ...
                                oriName(24));
                            
            if isfield(aggRepo, newName)
                continue
            end
            
            %Scaling the aggregates and getting the diameter of the
            %aggregate based on least-volume ellipsoid approximation
            curAgg = repos.(curAggName).Orientation.(oriName);
            curAggOriginal = repos.(curAggName).OriginalPoints;
            curAggDiameter = maxDiam(curAgg);
            scaleMat = [aggSizes(randi(100, 1))/curAggDiameter 0 0; ...
                                 0 aggSizes(randi(100, 1))/curAggDiameter 0; ...
                                 0 0 aggSizes(randi(100, 1))/curAggDiameter];
            curAgg = curAgg * scaleMat;
            curAggOriginal = normalizeTo(curAggOriginal, [0 0 0]);
            curAggOriginal = curAggOriginal * scaleMat;
            newAggDiameter = maxDiam(curAgg);
            
            angles = linspace(-pi/8,pi/8,5);
            curAggOriginal = Rotate(curAggOriginal, angles(oriX), angles(oriY), angles(oriZ));
            
            %Storing information into the struct
           aggRepo.(newName).Original = curAggName; %Store original name
           aggRepo.(newName).OriginalPoints = curAggOriginal;
           aggRepo.(newName).OriginalFaces = repos.(curAggName).OriginalFaces;
           aggRepo.(newName).Points = curAgg;
           aggRepo.(newName).Faces = repos.(aggNames{aggRandNum}).Faces; %Store connectivity
           aggRepo.(newName).Orientation = oriMat; %Indices for linspace
           aggRepo.(newName).Diameter = newAggDiameter;
           aggRepo.(newName).bin = bin;
           binAggNum = binAggNum + 1;
        end
    end
end

function datapointsn = normalizeTo(datapoints, newCentroid)
%Obtain the center of each aggregate
x = datapoints(:,1);
y = datapoints(:,2);
z = datapoints(:,3);

xcm = sum(x)./length(x);
ycm = sum(y)./length(y);
zcm = sum(z)./length(z);
centroid = [xcm ycm zcm];

%Obtain the matrix with the distance of each vertices to the center
datapointsn = datapoints;
dcm = centroid - newCentroid; %Distance from centroid to cubeCentroid
for vertice = 1:length(datapoints)
    datapointsn(vertice,:) = [datapoints(vertice,:) - dcm];
end
end

function dist = maxDiam(aggpts)
dist = 0;
for i = 1:length(aggpts)
    for k = 1:length(aggpts)
    distp = abs(norm(aggpts(i,:) - aggpts(k,:)));
    if distp > dist
        dist = distp;
    end
    end
end
end


function nv = Rotate(pts,tx,ty,tz) 
%Rotational matrix
rx = [1 0 0; 0 cos(tx) -sin(tx); 0 sin(tx) cos(tx)];
ry = [cos(ty) 0 sin(ty); 0 1 0; -sin(ty) 0 cos(ty)];
rz = [cos(tz) -sin(tz) 0; sin(tz) cos(tz) 0; 0 0 1];
rotm = rx*ry*rz;

nv = rotm*pts';
nv = nv';
end
